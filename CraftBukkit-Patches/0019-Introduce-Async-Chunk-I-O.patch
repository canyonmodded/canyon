From 59033e2df7ba18847c77b1cf88ef34841671f1ca Mon Sep 17 00:00:00 2001
From: Andrew Steinborn <git@steinborn.me>
Date: Sat, 5 Oct 2019 03:08:44 -0400
Subject: [PATCH] Introduce Async Chunk I/O

Highly experimental and only supports async chunk loads. More TBD.

diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 0b232fd1..e40138e7 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -21,6 +21,16 @@ import org.bukkit.generator.BlockPopulator;
 
 public class ChunkProviderServer implements IChunkProvider {
 
+    // Canyon start
+    private static final boolean DEBUG_SYNC_LOADS = Boolean.getBoolean("canyon.debug-sync-loads");
+    private static final java.util.concurrent.ExecutorService CHUNK_SERVICE = new java.util.concurrent.ThreadPoolExecutor(
+            Runtime.getRuntime().availableProcessors(), Runtime.getRuntime().availableProcessors(),
+            Integer.MAX_VALUE, java.util.concurrent.TimeUnit.SECONDS,
+            new java.util.concurrent.PriorityBlockingQueue<>(),
+            new com.canyonmodded.util.SimpleDaemonThreadFactory("Async Chunk I/O #%d"));
+    private LongHashtable<ChunkLoadTask> loadQueue = new LongHashtable<>();
+    // Canyon end
+
     // CraftBukkit start
     public LongHashset unloadQueue = new LongHashset();
     public Chunk emptyChunk;
@@ -54,29 +64,53 @@ public class ChunkProviderServer implements IChunkProvider {
         }
     }
 
-    public Chunk getChunkAt(int i, int j) {
+    // Canyon start
+    public Chunk getChunkIfLoaded(int x, int z) {
+        return this.chunks.get(x, z);
+    }
+
+    // Please note: this method has to be called in the main thread, but its result is emitted near-asynchronously
+    public java.util.concurrent.CompletableFuture<Chunk> getChunkAtAsync(int i, int j) {
+        return getChunkAtAsync(i, j, false);
+    }
+    public java.util.concurrent.CompletableFuture<Chunk> getChunkAtAsync(int i, int j, boolean immediate) {
         // CraftBukkit start
         this.unloadQueue.remove(i, j);
         Chunk chunk = (Chunk) this.chunks.get(i, j);
-        boolean newChunk = false;
+        //boolean newChunk = false; // Canyon - move
         // CraftBukkit end
 
-        if (chunk == null) {
-            chunk = this.loadChunk(i, j);
-            if (chunk == null) {
+        if (chunk != null) {
+            return java.util.concurrent.CompletableFuture.completedFuture(chunk);
+        } else {
+            if (immediate && DEBUG_SYNC_LOADS)  {
+                MinecraftServer.log.warning("SYNC CHUNK LOAD REQUEST @ " + i + "," + j);
+                new Throwable().printStackTrace();
+            }
+            return this.requestChunkLoad(i, j, immediate);
+        }
+    }
+
+    private Chunk postLoadTask(Chunk loadedChunk, int i, int j) {
+        // If the chunk is now loaded, just return the already existing chunk
+        if (this.chunks.containsKey(i, j)) {
+            return this.chunks.get(i, j);
+        }
+            boolean newChunk = false;
+            if (loadedChunk == null) {
                 if (this.chunkProvider == null) {
-                    chunk = this.emptyChunk;
+                    loadedChunk = this.emptyChunk;
                 } else {
-                    chunk = this.chunkProvider.getOrCreateChunk(i, j);
+                    loadedChunk = this.chunkProvider.getOrCreateChunk(i, j);
                 }
                 newChunk = true; // CraftBukkit
             }
 
-            this.chunks.put(i, j, chunk); // CraftBukkit
-            this.chunkList.add(chunk);
-            if (chunk != null) {
-                chunk.loadNOP();
-                chunk.addEntities();
+            this.chunks.put(i, j, loadedChunk); // CraftBukkit
+            this.chunkList.add(loadedChunk);
+            if (loadedChunk != null) {
+                loadedChunk.loadNOP();
+                loadedChunk.addEntities();
             }
 
             // CraftBukkit start
@@ -87,11 +121,13 @@ public class ChunkProviderServer implements IChunkProvider {
                  * the World constructor. We can't reliably alter that, so we have
                  * no way of creating a CraftWorld/CraftServer at that point.
                  */
-                server.getPluginManager().callEvent(new ChunkLoadEvent(chunk.bukkitChunk, newChunk));
+                server.getPluginManager().callEvent(new ChunkLoadEvent(loadedChunk.bukkitChunk, newChunk));
             }
             // CraftBukkit end
 
-            if (!chunk.done && this.isChunkLoaded(i + 1, j + 1) && this.isChunkLoaded(i, j + 1) && this.isChunkLoaded(i + 1, j)) {
+            // Canyon - remove code to load surrounding chunks, conflicts with async chunks
+            /*
+            if (!loadedChunk.done && this.isChunkLoaded(i + 1, j + 1) && this.isChunkLoaded(i, j + 1) && this.isChunkLoaded(i + 1, j)) {
                 this.getChunkAt(this, i, j);
             }
 
@@ -105,30 +141,44 @@ public class ChunkProviderServer implements IChunkProvider {
 
             if (this.isChunkLoaded(i - 1, j - 1) && !this.getOrCreateChunk(i - 1, j - 1).done && this.isChunkLoaded(i - 1, j - 1) && this.isChunkLoaded(i, j - 1) && this.isChunkLoaded(i - 1, j)) {
                 this.getChunkAt(this, i - 1, j - 1);
-            }
-        }
+            }*/
+
+            this.loadQueue.remove(i, j);
+            return loadedChunk;
 
-        return chunk;
+    }
+    public Chunk getChunkAt(int i, int j) {
+        Chunk chunk = this.chunks.get(i, j);
+        if (chunk != null) return chunk;
+
+        // Someone is going to block until we are done, so we need to do any post-init stuff after the load task completes
+        java.util.concurrent.CompletableFuture<Chunk> future = this.getChunkAtAsync(i, j, true);
+        try {
+            return postLoadTask(future.get(), i, j);
+        } catch (InterruptedException | java.util.concurrent.ExecutionException ex) {
+            ex.printStackTrace();
+            return null;
+        }
     }
 
     public Chunk getOrCreateChunk(int i, int j) {
-        // CraftBukkit start
-        Chunk chunk = (Chunk) this.chunks.get(i, j);
-
-        chunk = chunk == null ? (!this.world.isLoading && !this.forceChunkLoad ? this.emptyChunk : this.getChunkAt(i, j)) : chunk;
-        if (chunk == this.emptyChunk) return chunk;
-        if (i != chunk.x || j != chunk.z) {
-            MinecraftServer.log.info("Chunk (" + chunk.x + ", " + chunk.z + ") stored at  (" + i + ", " + j + ")");
-            MinecraftServer.log.info(chunk.getClass().getName());
-            Throwable ex = new Throwable();
-            ex.fillInStackTrace();
-            ex.printStackTrace();
+        Chunk loaded = this.getChunkAt(i, j);
+        if (loaded == this.emptyChunk) return loaded;
+        if (i != loaded.x || j != loaded.z) {
+            MinecraftServer.log.info("Chunk (" + loaded.x + ", " + loaded.z + ") stored at  (" + i + ", " + j + ")");
         }
-        return chunk;
-        // CraftBukkit end
+        return loaded;
     }
 
+    // Canyon start
     public Chunk loadChunk(int i, int j) { // CraftBukkit - private -> public
+        try {
+            return this.requestChunkLoad(i, j, true).get();
+        } catch (InterruptedException | java.util.concurrent.ExecutionException ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+    private Chunk realLoadChunk(int i, int j) {
         if (this.e == null) {
             return null;
         } else {
@@ -146,6 +196,7 @@ public class ChunkProviderServer implements IChunkProvider {
             }
         }
     }
+    // Canyon end
 
     public void saveChunkNOP(Chunk chunk) { // CraftBukkit - private -> public
         if (this.e != null) {
@@ -170,7 +221,6 @@ public class ChunkProviderServer implements IChunkProvider {
 
     public void getChunkAt(IChunkProvider ichunkprovider, int i, int j) {
         Chunk chunk = this.getOrCreateChunk(i, j);
-
         if (!chunk.done) {
             chunk.done = true;
             if (this.chunkProvider != null) {
@@ -265,4 +315,57 @@ public class ChunkProviderServer implements IChunkProvider {
     public boolean canSave() {
         return !this.world.canSave;
     }
+
+    // Canyon Start - async load process
+    private java.util.concurrent.CompletableFuture<Chunk> requestChunkLoad(int x, int z, boolean immediate) {
+        ChunkLoadTask task = this.loadQueue.get(x, z);
+        if (task == null) {
+            task = new ChunkLoadTask(x, z);
+            this.loadQueue.put(x, z, task);
+            if (immediate) {
+                task.toggleNeededImmediately();
+            }
+            CHUNK_SERVICE.execute(task);
+        } else {
+            if (immediate) {
+                task.toggleNeededImmediately();
+            }
+        }
+
+        if (immediate) {
+            return task.immediate;
+        } else {
+            return task.result;
+        }
+    }
+
+    private class ChunkLoadTask implements Runnable, Comparable<ChunkLoadTask> {
+        private final int x;
+        private final int z;
+        private final java.util.concurrent.atomic.AtomicBoolean neededImmediately = new java.util.concurrent.atomic.AtomicBoolean(false);
+        private final java.util.concurrent.CompletableFuture<Chunk> immediate = new java.util.concurrent.CompletableFuture<>();
+        private final java.util.concurrent.CompletableFuture<Chunk> result = new java.util.concurrent.CompletableFuture<>();
+
+        private ChunkLoadTask(int x, int z) {
+            this.x = x;
+            this.z = z;
+        }
+
+        void toggleNeededImmediately() {
+            neededImmediately.set(true);
+        }
+
+        @Override
+        public void run() {
+            Chunk loaded = realLoadChunk(x, z);
+            immediate.complete(loaded);
+            world.server.queueTask(() -> result.complete(ChunkProviderServer.this.postLoadTask(loaded, x, z)));
+        }
+
+        @Override
+        public int compareTo(ChunkLoadTask o) {
+            return Boolean.compare(o.neededImmediately.get(), neededImmediately.get());
+        }
+    }
+    // Canyon End
 }
diff --git a/src/main/java/net/minecraft/server/NetLoginHandler.java b/src/main/java/net/minecraft/server/NetLoginHandler.java
index dd45b44b..c141051e 100644
--- a/src/main/java/net/minecraft/server/NetLoginHandler.java
+++ b/src/main/java/net/minecraft/server/NetLoginHandler.java
@@ -109,6 +109,11 @@ public class NetLoginHandler extends NetHandler implements com.canyonmodded.netw
             a.info(this.b() + " logged in with entity id " + entityplayer.id + " at ([" + entityplayer.world.worldData.name + "] " + entityplayer.locX + ", " + entityplayer.locY + ", " + entityplayer.locZ + ")");
             WorldServer worldserver = (WorldServer) entityplayer.world; // CraftBukkit
             ChunkCoordinates chunkcoordinates = worldserver.getSpawn();
+
+            // Canyon Start - Async Chunk I/O, load the player's spawn chunk here
+            int playerChunkX = (int) Math.floor(entityplayer.locX) >> 4;
+            int playerChunkZ = (int) Math.floor(entityplayer.locZ) >> 4;
+            worldserver.chunkProviderServer.getChunkAtAsync(playerChunkX, playerChunkZ).thenRun(() -> {
             NetServerHandler netserverhandler = new NetServerHandler(this.server, this.networkManager, entityplayer);
 
             netserverhandler.sendPacket(new Packet1Login("", entityplayer.id, worldserver.getSeed(), (byte) worldserver.worldProvider.dimension));
@@ -120,6 +125,8 @@ public class NetLoginHandler extends NetHandler implements com.canyonmodded.netw
             if (this.server.networkListenThread != null) this.server.networkListenThread.a(netserverhandler); // Canyon
             netserverhandler.sendPacket(new Packet4UpdateTime(entityplayer.getPlayerTime())); // CraftBukkit - add support for player specific time
             entityplayer.syncInventory();
+            });
+            // Canyon End
         }
 
         this.c = true;
diff --git a/src/main/java/net/minecraft/server/PlayerInstance.java b/src/main/java/net/minecraft/server/PlayerInstance.java
index 3c7706d5..d32d70db 100644
--- a/src/main/java/net/minecraft/server/PlayerInstance.java
+++ b/src/main/java/net/minecraft/server/PlayerInstance.java
@@ -28,7 +28,7 @@ class PlayerInstance {
         this.chunkX = i;
         this.chunkZ = j;
         this.location = new ChunkCoordIntPair(i, j);
-        playermanager.a().chunkProviderServer.getChunkAt(i, j);
+        playermanager.a().chunkProviderServer.getChunkAtAsync(i, j); // Canyon - async chunk loading
     }
 
     public void a(EntityPlayer entityplayer) {
diff --git a/src/main/java/net/minecraft/server/ServerConfigurationManager.java b/src/main/java/net/minecraft/server/ServerConfigurationManager.java
index 981f058a..0fcff6b7 100644
--- a/src/main/java/net/minecraft/server/ServerConfigurationManager.java
+++ b/src/main/java/net/minecraft/server/ServerConfigurationManager.java
@@ -89,7 +89,7 @@ public class ServerConfigurationManager {
         this.getPlayerManager(entityplayer.dimension).addPlayer(entityplayer);
         WorldServer worldserver = this.server.getWorldServer(entityplayer.dimension);
 
-        worldserver.chunkProviderServer.getChunkAt((int) entityplayer.locX >> 4, (int) entityplayer.locZ >> 4);
+        worldserver.chunkProviderServer.getChunkAtAsync((int) entityplayer.locX >> 4, (int) entityplayer.locZ >> 4); // Canyon - async chunk loading
     }
 
     public int a() {
@@ -113,7 +113,7 @@ public class ServerConfigurationManager {
         this.players.add(entityplayer);
         WorldServer worldserver = this.server.getWorldServer(entityplayer.dimension);
 
-        worldserver.chunkProviderServer.getChunkAt((int) entityplayer.locX >> 4, (int) entityplayer.locZ >> 4);
+        //worldserver.chunkProviderServer.getChunkAt((int) entityplayer.locX >> 4, (int) entityplayer.locZ >> 4); // Canyon - remove sync chunk load, done in NetLoginHandler async
 
         while (worldserver.getEntities(entityplayer, entityplayer.boundingBox).size() != 0) {
             entityplayer.setPosition(entityplayer.locX, entityplayer.locY + 1.0D, entityplayer.locZ);
-- 
2.22.0

